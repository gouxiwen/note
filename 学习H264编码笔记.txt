
H264编解码概述

三种头信息
SPS （Sequence Parameter Set，序列参数集）信息
PPS（Picture Parameter Set，图像参数集）信息
每个关键帧前面都要加上SPS和PPS
SEI中一般存储了H.264中的一些附加信息

帧内预测
初始化Intra16x16帧内预测汇编函数
16x16帧内预测一共有4种
1.Vertical
由上边像素推出相应像素值
2.Horizontal
由左边像素推出相应像素值
3.DC
由上边和左边像素平均值推出相应像素值
4.Plane
由上边和左边像素推出相应像素值

初始化Intra4x4帧内预测汇编函数
4x4帧内预测模式一共有9种

以16x16Vertical为例说明，就是一个16x16的宏块预测的像素来自它上面的16个像素。

预测出来的像素需要和原始像素进行比较计算，因此需要像素计算函数，一共有三种SAD、SATD、SSD，其中SAD和SATD主要用于帧内预测模式以及帧间预测模式的判断。定义如下：

SAD（Sum of Absolute Difference）也可以称为SAE（Sum of Absolute Error），即绝对误差和。它的计算方法就是求出两个像素块对应像素点的差值，将这些差值分别求绝对值之后再进行累加。
SATD（Sum of Absolute Transformed Difference）即Hadamard变换后再绝对值求和。它和SAD的区别在于多了一个“变换”。
SSD（Sum of Squared Difference）也可以称为SSE（Sum of Squared Error），即差值的平方和。它和SAD的区别在于多了一个“平方”。

通过像素计算函数比较出差值最小的预测模式，从而作为编码预测模式。而使用SATD计算的值比SAD计算的值更能准确地反映生成码流的大小，因此h264帧内预测使用SATD作为计算函数。

运动估计和运动补偿（在帧间预测中）
当参考帧和编码帧中某一块的内容一样但是位置不一样时就需要进行运动估计（通过运动搜索计算，就是在参考帧中找和编码帧中某一块差值最小的块）找参考块的位置，这个参考块及位置就是参考帧和运动矢量，得到的运动矢量如果简单处理就会被编码到编码信息中，但实际中还要和周围的相邻块的运动矢量预测值做个差值SAD，把差值编码到编码信息中。
这里运动矢量不一定是一个整像素，因此需要就需要插值算法算出半像素值和更精确的1/4像素值（的参考块），通过比较三种运动矢量和编码块的差值，找到差值SAD最小的运动矢量。

DCT变换
DCT变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，这样就可以在压缩的时候（量化）去除掉人眼不敏感的高频信息（位于矩阵右下角的系数）从而达到压缩数据的目的。

用上面选择出来的预测模式计算出预测块之后和原始图计算得到差值，再将差值进行DCT变换，得到DCT系数，这个值在后面的量化中使用。

量化和反量化
量化就是将DTC变换后的数值除以某个数字（和QStep有关）得到更多的0，QStep越大得到更多的0，压缩比越大

熵编码
上面讲到0越多压缩比越大，为什么？
答案就是熵编码，熵编码就是用更少的文字表示信息，例如0000000可以用70表示

环路滤波（去块效应滤波）
重建帧相邻块之间有边缘块，产生这种效应的原因主要有两个：
（1）DCT变换后的量化造成误差（主要原因）。
（2）运动补偿
环路滤波器就是用来消除这种边缘的，使画面平滑

编码过程详解

获取一帧的编码帧fenc和重建帧fdec，编码帧用于存放元数据，重建帧用于存放预测的数据
如果frames.unused[]队列不为空，从frames.unused[]队列尾部获取
如果frames.unused[]队列为空，则新建一帧

新建帧
声明了一个frame指针，然后对成员变量进行内存分配和注释
颜色空间的转换，将各种外部颜色空间转为内部颜色空间YUV，根据不同的外部颜色空间可以转为420，422，444三种
拷贝帧数据，将外部结构体图像拷贝到内部结构体，根据上面转换的YUV的格式复制像素
接下来确定帧类型（I/IDR，P，B），这里回将一组帧放一起进行计算。
这是个很复杂的过程，简单理解就是首先判断是否为场景切换，如果是则这是为I帧，直接返回，如果不是场景切换，则判断是否可以使用B帧（B帧在rtc场景不适用），如果不能使用B帧则全部设为P帧，如果可以使用B帧则还要进行比较复杂的帧开销计算来确定每个帧的类型。
一帧的开销是多个slice开销的总和，一个slice又是多个宏块开销的总和，通过比较作为P帧的帧内预测、作为P帧的帧间预测、作为B帧的帧内预测、作为B帧的帧间预测，选择一组最小开销的帧类型组合，这个过程是个速算过程，处理的是低分辨率的图片，宏块大小是8*8。
经过一些列分析之后，最终确定了帧类型信息，并且将帧放入frames.current[]队列。
从frames.current[]队列取出1帧用于编码。
如果不是IDR帧，更新参考帧队列，如果重建帧fdec是不被参考的B帧则不更新。否则重建帧移植参考帧列表，并新建一个重建帧。
如果是IDR帧，清空参考帧列表。
开始编码数据

编码是以slice为最小单位进行的，一个slice为一个大循环，然后每个宏块是个小循环，宏块循环里一行一行进行编码，所有宏块编码完成，退出大循环。

对于每一个宏块，经过帧内或者帧间预测算出编码块和重建块的残差，然后对残差进行DTC变换。

DTC变换
全称叫离散余弦变换（Discrete Cosine Transform），是一种数字处理方法，将空间域图像变换到频率域上，在空间域看来，图像内容千差万别；但在频率域上，经过对大量图像的统计分析发现，图像经过DCT变换后，其频率系数的主要成分集中于比较小的范围，且主要位于低频部分。

Z字形扫描
差值经过DCT变换后的系数矩阵左上角的数值较大，而右下角的数值较小，且趋近于零值。于是，可以按照Z字形扫描顺序，将各基信号的DCT系数列成一个表格。将二维数据量转换为一维数据量，该数列第一项是该区块的平均亮度值，后面各项系数的分布和大小可以反映亮度起伏变化的剧烈程度。若系数较大，说明亮度起伏较大，该区域图像轮廓较细致；若数值较小，则说明该区内亮度变化较平缓；若数值为零，表示数列中高频分量数值为零，亮度电平无变化。在实际数据处理过程中，排在后面的系数值基本上都有是零值，或者趋于零值。
低频系数反应的是图像的主题部分，高频系数反应的是图像的细节，人眼对高频系数不敏感。
这样差值经DCT变化后的系数再经Z字形字扫描后所形成的数据系列，恰好与人眼睛对图像信息的敏感程度形成良好的对应关系。这个对于关系方便后续量化时取得统计性灵敏度数值，确定折算值。
DCT详解参考：http://t.zoukankan.com/stnlcd-p-7261842.html

量化
量化过程就是根据QP值给DTC系数除以对应的Qstep值，在H264中量化过程除了完成本职工作外，还需要完成它前一步DCT变换中“系数相乘”的工作，即将DCT变换和量化合并，这个过程完全为整数运算，同时避免了除法的使用，减少了浮点运算带来的误差。

保存当前宏块的的值，用于以后的宏块的编码
保存内容包括Intra4x4宏块帧内预测模式，DCT非零系数，运动矢量，参考帧序号等等

滤波模块详解
滤波模块在slice编码中调用，用于在宏编码中进行环路滤波、半像素插值和视频质量指标PSNR和SSIM的计算。

环路滤波
环路滤波用来消除重建帧的块状效应，块状效应主要是DCT变换后的量化造成误差和运动补偿引起的，那编码阶段的环路滤波应该主要是为了消除运动补偿？（不确定）
根据强度分为强滤波Bs=4和普通滤波Bs=1,2,3，强滤波会计算边界两边各四个像素，普通滤波会计算边界两边各三个像素。
根据编码内容分为亮度滤波和色度滤波
对一个宏块的水平和处置各四条边分别进行滤波计算，其中最左边和最上边的变采用强滤波，其余边采用普通滤波。
在进行滤波处理之前先要判断是否需要进行滤波，判断的依据是两个门限值alpha和beta，根据QP，通过查表的方法获得是否滤波的门限值alpha和beta
alpha为边界两边2点的门限值
beta为边界一边最靠近边界的2点的门限值
总体说来，QP越大，alpha和beta越大，越有可能滤波
alpha或者beta有一个门限为0的时候，就不用滤波

半像素插值
（1）半像素内插。这一步通过6抽头滤波器获得5个半像素点。
（2）线性内插。这一步通过简单的线性内插获得剩余的1/4像素点。

视频质量计算-PSNR和SSIM
PSNR（Peak Signal to Noise Ratio，峰值信噪比）是最基础的视频质量评价方法。它的取值一般在20-50之间，值越大代表受损图片越接近原图片。
但是PSNR仅仅计算了图像像素点间的绝对误差，没有考虑像素点间的视觉相关性，更没顾及人类视觉系统的感知特性，所以其评价结果与主观感受往往相差较大。
SSIM（Structural SIMilarity，结构相似度）是一种结合了亮度信息，对比度信息以及结构信息的视频质量评价方法。它的取值在0-1之间，值越大代表受损图片越接近原图片。


