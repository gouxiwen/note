
x264是一个H.264/MPEG4 AVC 编码器
x264编码概述

码流中图像数的最小单位是slice，帧可以划分为一个或者多个 Slice，码流的最小编码单元是NALU，每个slice是一个NALU，除了slice之外还有三种NALU，SPS、PPS、SEI
SPS （Sequence Parameter Set，序列参数集）信息，编码相关的信息，熵编码类型、基础 QP 和最大参考帧数量等
PPS（Picture Parameter Set，图像参数集）信息，图像自身的信息，宽、高、YUV、位深等
每个关键帧前面都要加上SPS和PPS
SEI中一般存储了H.264中的一些附加信息

帧内预测
初始化Intra16x16帧内预测汇编函数
16x16帧内预测一共有4种
1.Vertical
由上边像素推出相应像素值
2.Horizontal
由左边像素推出相应像素值
3.DC
由上边和左边像素平均值推出相应像素值
4.Plane
由上边和左边像素推出相应像素值

初始化Intra4x4帧内预测汇编函数
4x4帧内预测模式一共有9种

以16x16Vertical为例说明，就是一个16x16的宏块预测的像素来自它上面的16个像素。

预测出来的像素需要和原始像素进行比较计算，因此需要像素计算函数，一共有三种SAD、SATD、SSD，其中SAD和SATD主要用于帧内预测模式以及帧间预测模式的判断。定义如下：

SAD（Sum of Absolute Difference）也可以称为SAE（Sum of Absolute Error），即绝对误差和。它的计算方法就是求出两个像素块对应像素点的差值，将这些差值分别求绝对值之后再进行累加。
SATD（Sum of Absolute Transformed Difference）即Hadamard变换后再绝对值求和。它和SAD的区别在于多了一个“变换”。
SSD（Sum of Squared Difference）也可以称为SSE（Sum of Squared Error），即差值的平方和。它和SAD的区别在于多了一个“平方”。

通过像素计算函数比较出差值最小的预测模式，从而作为编码预测模式。而使用SATD计算的值比SAD计算的值更能准确地反映生成码流的大小，因此h264帧内预测使用SATD作为计算函数。

运动估计和运动补偿（在帧间预测中）
当参考帧和编码帧中某一块的内容一样但是位置不一样时就需要进行运动估计（通过运动搜索计算，就是在参考帧中找和编码帧中某一块差值最小的块）找参考块的位置，这个参考块及位置就是参考帧和运动矢量，得到的运动矢量如果简单处理就会被编码到编码信息中，但实际中还要和周围的相邻块的运动矢量预测值做个差值SAD，把差值编码到编码信息中。
这里运动矢量不一定是一个整像素，因此需要就需要插值算法算出半像素值和更精确的1/4像素值（的参考块），通过比较三种运动矢量和编码块的差值，找到差值SAD最小的运动矢量。

DCT变换
DCT变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，这样就可以在压缩的时候（量化）去除掉人眼不敏感的高频信息（位于矩阵右下角的系数）从而达到压缩数据的目的。

用上面选择出来的预测模式计算出预测块之后和原始图计算得到差值，再将差值进行DCT变换，得到DCT系数，这个值在后面的量化中使用。
DC系数和AC系数。 
量化后得到的仍是64个系数，量化并没有改变系数的性质。大家知到DCT变换是将数据域从时（空）域变换到频域，在频域平面上变换系数是二维频域变量u和v的函数。对应于u=0，v=0的系数，称做直流分量，即DC系数，其余63个系数称做AC系数，即交流分量。

DC系数：对应于u=0，v=0的系数，称做直流分量，即DC系数。 
AC系数：其余63个系数称做AC系数，即交流分量。

量化和反量化
量化就是将DTC变换后的数值除以某个数字（和QStep有关）得到更多的0，QStep越大得到更多的0，压缩比越大

熵编码
上面讲到0越多压缩比越大，为什么？
答案就是熵编码，熵编码就是用更少的文字表示信息，例如0000000可以用70表示

环路滤波（去块效应滤波）
重建帧相邻块之间有边缘块，产生这种效应的原因主要有两个：
（1）DCT变换后的量化造成误差（主要原因）。
（2）运动补偿
环路滤波器就是用来消除这种边缘的，使画面平滑

编码过程详解

获取一帧的编码帧fenc和重建帧fdec，编码帧用于存放元数据，重建帧用于存放编码后的残差经过反量化和反DCT变换后加上预测的数据。（即把解码过程先进行一次得到和解码时一样的数据）
如果frames.unused[]队列不为空，从frames.unused[]队列尾部获取
如果frames.unused[]队列为空，则新建一帧

新建帧
声明了一个frame指针，然后对成员变量进行内存分配和注释
颜色空间的转换，将各种外部颜色空间转为内部颜色空间YUV，根据不同的外部颜色空间可以转为420，422，444三种
拷贝帧数据，将外部结构体图像拷贝到内部结构体，根据上面转换的YUV的格式复制像素
接下来确定帧类型（I/IDR，P，B），这里回将一组帧放一起进行计算。
这是个很复杂的过程，简单理解就是首先判断是否为场景切换，如果是则这是为I帧，直接返回，如果不是场景切换，则判断是否可以使用B帧（B帧在rtc场景不适用），如果不能使用B帧则全部设为P帧，如果可以使用B帧则还要进行比较复杂的帧开销计算来确定每个帧的类型。
一帧的开销是多个slice开销的总和，一个slice又是多个宏块开销的总和，通过比较作为P帧的帧内预测、作为P帧的帧间预测、作为B帧的帧内预测、作为B帧的帧间预测，选择一组最小开销的帧类型组合，这个过程是个速算过程，处理的是低分辨率的图片，宏块大小是8*8。
经过一些列分析之后，最终确定了帧类型信息，并且将帧放入frames.current[]队列。
从frames.current[]队列取出1帧用于编码。
如果不是IDR帧，更新参考帧队列，如果重建帧fdec是不被参考的B帧则不更新。否则重建帧移植参考帧列表，并新建一个重建帧。
如果是IDR帧，清空参考帧列表。
开始编码数据

编码是以slice为最小单位进行的，一个slice为一个大循环，然后每个宏块是个小循环，宏块循环里一行一行进行编码，所有宏块编码完成，退出大循环。

对于每一个宏块，经过帧内或者帧间预测算出编码块和重建块的残差，然后对残差进行DTC变换。

DTC变换（在4x4块上做，不论宏块是否分割为4x4）
全称叫离散余弦变换（Discrete Cosine Transform），是一种数字处理方法，将空间域图像变换到频率域上，在空间域看来，图像内容千差万别；但在频率域上，经过对大量图像的统计分析发现，图像经过DCT变换后，其频率系数的主要成分集中于比较小的范围，且主要位于低频部分。

Z字形扫描
差值经过DCT变换后的系数矩阵左上角的数值较大，而右下角的数值较小，且趋近于零值。于是，可以按照Z字形扫描顺序，将各基信号的DCT系数列成一个表格。将二维数据量转换为一维数据量，该数列第一项是该区块的平均亮度值，后面各项系数的分布和大小可以反映亮度起伏变化的剧烈程度。若系数较大，说明亮度起伏较大，该区域图像轮廓较细致；若数值较小，则说明该区内亮度变化较平缓；若数值为零，表示数列中高频分量数值为零，亮度电平无变化。在实际数据处理过程中，排在后面的系数值基本上都有是零值，或者趋于零值。
低频系数反应的是图像的主题部分，高频系数反应的是图像的细节，人眼对高频系数不敏感。
这样差值经DCT变化后的系数再经Z字形字扫描后所形成的数据系列，恰好与人眼睛对图像信息的敏感程度形成良好的对应关系。这个对于关系方便后续量化时取得统计性灵敏度数值，确定折算值。
DCT详解参考：http://t.zoukankan.com/stnlcd-p-7261842.html

量化
量化过程就是根据QP值给DTC系数除以对应的Qstep值，在H264中量化过程除了完成本职工作外，还需要完成它前一步DCT变换中“系数相乘”的工作，即将DCT变换和量化合并，这个过程完全为整数运算，同时避免了除法的使用，减少了浮点运算带来的误差。

保存当前宏块的的值，用于以后的宏块的编码
保存内容包括Intra4x4宏块帧内预测模式，DCT非零系数，运动矢量，参考帧序号等等

滤波模块详解
滤波模块在slice编码中调用，用于在宏编码中进行环路滤波、半像素插值和视频质量指标PSNR和SSIM的计算。

环路滤波
环路滤波用来消除重建帧的块状效应，块状效应主要是DCT变换后的量化造成误差和运动补偿引起的，那编码阶段的环路滤波应该主要是为了消除运动补偿？（不确定）
根据强度分为强滤波Bs=4和普通滤波Bs=1,2,3，强滤波会计算边界两边各四个像素，普通滤波会计算边界两边各三个像素。
根据编码内容分为亮度滤波和色度滤波
对一个宏块的水平和处置各四条边分别进行滤波计算，其中最左边和最上边的变采用强滤波，其余边采用普通滤波。
在进行滤波处理之前先要判断是否需要进行滤波，判断的依据是两个门限值alpha和beta，根据QP，通过查表的方法获得是否滤波的门限值alpha和beta
alpha为边界两边2点的门限值
beta为边界一边最靠近边界的2点的门限值
总体说来，QP越大，alpha和beta越大，越有可能滤波
alpha或者beta有一个门限为0的时候，就不用滤波

半像素插值
（1）半像素内插。这一步通过6抽头滤波器获得5个半像素点。
（2）线性内插。这一步通过简单的线性内插获得剩余的1/4像素点。

视频质量计算-PSNR和SSIM
PSNR（Peak Signal to Noise Ratio，峰值信噪比）是最基础的视频质量评价方法。它的取值一般在20-50之间，值越大代表受损图片越接近原图片。
但是PSNR仅仅计算了图像像素点间的绝对误差，没有考虑像素点间的视觉相关性，更没顾及人类视觉系统的感知特性，所以其评价结果与主观感受往往相差较大。
SSIM（Structural SIMilarity，结构相似度）是一种结合了亮度信息，对比度信息以及结构信息的视频质量评价方法。它的取值在0-1之间，值越大代表受损图片越接近原图片。

宏块分析详解
I帧：只使用帧内预测，分别计算亮度16x16（4种）和4x4（9种）所有模式的代价值，选出代价最小的模式
P帧：计算帧内模式和帧间模式（ P Slice允许有Intra宏块和P宏块；同理B帧也支持Intra宏块）。
对P帧的每一种分割进行帧间预测，得到最佳的运动矢量及最佳匹配块。
帧间预测过程：选出最佳矢量——>找到最佳的整像素点——>找到最佳的二分之一像素点——>找到最佳的1/4像素点
然后取代价最小的为最佳MV和分割方式
最后从帧内模式和帧间模式中选择代价比较小的方式（有可能没有找到很好的匹配块，这时候就直接使用帧内预测而不是帧间预测）。

//帧内预测分析
从16×16的SAD,4个8×8的SAD和，16个4×4SAD中选出最优帧内方式
//帧间预测分析
先分析16x16和8x8宏块，如果8x8的代价值小于16x16，则进行8x8子块分割的处理和16x8/8x16分析。
8x8块先分成4x4块分析，如果4x4小于8x8，则再分析8x4，4x8的代价。
从以上不同分割中选出最优帧间方式。

可以看到一个slice的每个16x16的块使用哪种预测模式都是互相独立的。

疑问：
帧内预测slice内的第一个块参考什么？

编码宏块详解
分别对亮度Y和色度U、V进行编码
编码过程是先根据之前分析过程得到的预测模式和宏块分割方式编码、DCT变换、量化得到编码数据
再将编码数据进行反量化、反DCT变换、加上预测数据到的重建帧，重建帧可以加入到参考帧列表。

熵编码详解
根据Slice类型的不同，调用不同的函数输出宏块头（MB Header）
宏块头包括：帧内预测模式、MVD、参考帧序号等。
H.264码流中并不是直接保存了每个子块的帧内预测方式（不利于压缩）。而是优先通过有周围块的信息推测当前块的帧内预测模式。具体的方法就是获取到左边块和上边块的预测模式，然后取它们的最小值作为当前块的预测模式，与当前宏块实际的预测模式进行比较，如果正好相等则可以略去不传，如果不等的话则传送它们的差值。

以上：h264编码部分就完成了。

FFmpeg与libx264接口源代码简单分析
FFmpeg是一个包含了处理多媒体的工具和库的集合，其中libavcodec 是一个包含音频/视频编解码器的解码器和编码器的库。
libavcodec中与libx264有关的部分位于“libavcodec/libx264.c”中，它的作用是将ffmpeg的各种设置和像素格式转换为libx264的设置格式并且传递给libx264进行编码，编码完成后转成ffmpeg的格式输出。
这里有三个部分，初始化编码器、编码、关闭编码器。
初始化部分：
设置默认参数
libx264日志输出设置为FFmpeg的日志输出
FFmpeg像素格式映射到libx264
FFmpeg码率映射到libx264
FFmpeg运动估计方法映射到libx264
把AVCodecContext的值（主要是编码时候的一些通用选项）映射到x264_param_t
把X264Context中的信息（主要是针对于libx264的一些选项）映射到x264_param_t
设置Profile：宽高，帧率等
设置完参数后，打开编码器，如果需要全局头，设置全局头

编码部分：
x264_encoder_encode()的输入是x264_picture_t，输出是x264_nal_t；而X264_frame()的输入是AVFrame，输出是AVPacket。因此X264_frame()在调用编码函数前将AVFrame转换成了x264_picture_t，而在调用编码函数之后调用encode_nals()将x264_nal_t转换成了AVPacket。

关闭编码器部分：
调用x264_encoder_close()关闭了libx264编码器。