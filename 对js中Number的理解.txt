JavaScript中的Number类型遵守的是IEEE 754 64标准，而这个标准中的64表示的就是64位， 也就是说遵守这种标准的数字是通过64个0或1来存储的。

十进制转换二进制，整数部分和小数部分分别计算

十进制整数：不断的除以2自下而上取余数，直到除尽
十进制小数：不断的乘以2自上而下取整数位，直到小数部分为0

19.8125D = 10011.1101B


科学计数法
科学计数法主要由四部分所组成：首位、精确度（有效数字）、进制、指数
在JavaScript中所要表示的数字范围非常大，因此IEEE 754 64是通过二进制科学计数法的形式来存储数据的，而不是普通的二进制存储。这一点非常重要，不理解这一点就很难理解number的底层逻辑。

内存储存形式
符号位s(1bit)指数位E(11bit)小数位或者分数位F(52bit)，这里的小数位在科学计算中只得是精度

内存里没有存首位，因为二进制的首位只能是0或者1，0是个特殊值，只能是1，计算时取1
同样内存里没有存进制，计算时取2

因此二进制科学计数公式就是
-1^s x(1.F)x2^E

把二进制表示的s,1.F,E都转成十进制进行计算
指数E的范围是[0,2047]，去掉非规约数后范围是[1,2046],为了表示小数E还需进行偏移，计算的时候要减去1023
1.F转成十进制
首先去掉小数点
（F位数+1个1）*2^-(F位数)
然后转成十进制
(2^(F位数+1) - 1) * 2^-(F位数)
2.带入公式计算
如要表示最大数，则s取0，F是52个1，E取2046

max =( 2**53 - 1)* 2**-52 * 2 ** (2046-1023) = 1.7976931348623157e+308
这也是Number.MAX_VALUE的结果

前面在指数调整时提到要对指数进行掐头去尾，而被去掉的头尾结合分数部分的值构成了IEEE 754的分类标准。根据这个分类标准，将数值类型分为了三类。规约数、非规约数和特殊值。
这些概念比较复杂，都是一些规则，规定了E，F的取值。

Number.MAX_VALUE是规约数的最大值，而最小值是一个非规约数

IEEE 754 所能表示的最大值并不是64个1，而是2^1024。即第0 ~ 51位分数位全为0，第52 ~ 62指数位全为1,63位符号位为0表示正数。

infinity = 2**1024 = Infinity
这也是Number.POSITIVE_INFINITY的结果

要保证整数的结果就要以小数位的最大位来判断，因此小数位52位，加首位1位，最大安全整数就是2**53 - 1 = 9007199254740991

这是是Number.MAX_SAFE_INTEGER的结果

0.1+0.2 为什么不等于0.3???

产生这个问题的原因在于计算时会发生转换和移位两次精度损失。

0.1和0.2转成二进制时会产值循环，而内存中小数位只有52位，这里会丢失精度

科学计数法做加法计算时要先保证指数相等，指数不相等需要移位，这造成了第二次精度损失。


参考：https://juejin.cn/post/7170533987562029087
